name: Build and Release DMG

on:
  push:
    branches:
      - main
    paths-ignore:
      - '**.md'

permissions:
  contents: write

jobs:
  build:
    runs-on: macos-latest
    outputs:
      skip: ${{ steps.check_commit.outputs.skip }}
      version: ${{ steps.version.outputs.version }}
      build: ${{ steps.version.outputs.build }}

    steps:
      - name: Checkout code
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4.3.1
        with:
          fetch-depth: 0

      - name: Check if commit is version bump
        id: check_commit
        run: |
          COMMIT_MSG=$(git log -1 --pretty=%B)
          if [[ "$COMMIT_MSG" == "Bump version to"* ]]; then
            echo "skip=true" >> $GITHUB_OUTPUT
            echo "This is a version bump commit, skipping workflow"
          else
            echo "skip=false" >> $GITHUB_OUTPUT
            echo "This is a regular commit, proceeding with release"
          fi

      - name: Get current version and increment
        if: steps.check_commit.outputs.skip == 'false'
        id: version
        run: |
          CURRENT_VERSION=$(/usr/libexec/PlistBuddy -c "Print :CFBundleShortVersionString" ClipClap/Info.plist)
          CURRENT_BUILD=$(/usr/libexec/PlistBuddy -c "Print :CFBundleVersion" ClipClap/Info.plist)

          echo "Current version: $CURRENT_VERSION (build $CURRENT_BUILD)"

          if git tag | grep -q "^v${CURRENT_VERSION}$"; then
            IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
            MAJOR="${VERSION_PARTS[0]}"
            MINOR="${VERSION_PARTS[1]:-0}"
            PATCH="${VERSION_PARTS[2]:-0}"
            PATCH=$((PATCH + 1))
            NEW_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          else
            NEW_VERSION="$CURRENT_VERSION"
          fi

          NEW_BUILD=$((CURRENT_BUILD + 1))

          echo "New version: $NEW_VERSION (build $NEW_BUILD)"
          echo "version=$NEW_VERSION" >> $GITHUB_OUTPUT
          echo "build=$NEW_BUILD" >> $GITHUB_OUTPUT

      - name: Build app (unsigned validation)
        if: steps.check_commit.outputs.skip == 'false'
        run: |
          xcodebuild -project ClipClap.xcodeproj \
            -scheme ClipClap \
            -configuration Release \
            -derivedDataPath build \
            clean build \
            CODE_SIGN_IDENTITY="" \
            CODE_SIGNING_REQUIRED=NO \
            CODE_SIGNING_ALLOWED=NO

  sign-and-release:
    needs: build
    if: needs.build.outputs.skip == 'false'
    runs-on: macos-latest
    environment: release

    steps:
      - name: Checkout code
        uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4.3.1
        with:
          fetch-depth: 0

      - name: Update version in plist
        run: |
          VERSION="${{ needs.build.outputs.version }}"
          BUILD="${{ needs.build.outputs.build }}"
          /usr/libexec/PlistBuddy -c "Set :CFBundleShortVersionString $VERSION" ClipClap/Info.plist
          /usr/libexec/PlistBuddy -c "Set :CFBundleVersion $BUILD" ClipClap/Info.plist

      - name: Import signing certificate
        env:
          APPLE_CERTIFICATE_BASE64: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: |
          # Create a temporary keychain
          KEYCHAIN_PATH="$RUNNER_TEMP/app-signing.keychain-db"
          KEYCHAIN_PASSWORD="$(openssl rand -base64 32)"

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Import certificate
          CERT_PATH="$RUNNER_TEMP/certificate.p12"
          echo "$APPLE_CERTIFICATE_BASE64" | base64 --decode > "$CERT_PATH"

          security import "$CERT_PATH" \
            -P "$APPLE_CERTIFICATE_PASSWORD" \
            -A \
            -t cert \
            -f pkcs12 \
            -k "$KEYCHAIN_PATH"

          # Set keychain as default and add to search list
          security list-keychain -d user -s "$KEYCHAIN_PATH"
          security set-key-partition-list -S apple-tool:,apple: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Clean up certificate file
          rm -f "$CERT_PATH"

          # Save keychain path for cleanup step
          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> $GITHUB_ENV

      - name: Build and archive app
        env:
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          xcodebuild -project ClipClap.xcodeproj \
            -scheme ClipClap \
            -configuration Release \
            -derivedDataPath build \
            -archivePath build/ClipClap.xcarchive \
            archive \
            CODE_SIGN_STYLE=Manual \
            CODE_SIGN_IDENTITY="Developer ID Application" \
            DEVELOPMENT_TEAM="$APPLE_TEAM_ID" \
            OTHER_CODE_SIGN_FLAGS="--options=runtime"

      - name: Export archive
        env:
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          cat > /tmp/ExportOptions.plist << EOF
          <?xml version="1.0" encoding="UTF-8"?>
          <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
          <plist version="1.0">
          <dict>
              <key>method</key>
              <string>developer-id</string>
              <key>teamID</key>
              <string>${APPLE_TEAM_ID}</string>
              <key>signingStyle</key>
              <string>automatic</string>
              <key>signingCertificate</key>
              <string>Developer ID Application</string>
          </dict>
          </plist>
          EOF

          cat /tmp/ExportOptions.plist

          xcodebuild -exportArchive \
            -archivePath build/ClipClap.xcarchive \
            -exportPath build/Export \
            -exportOptionsPlist /tmp/ExportOptions.plist

      - name: Notarize app
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          # Create a zip for notarization submission
          ditto -c -k --keepParent "build/Export/ClipClap.app" build/ClipClap.zip

          # Submit for notarization and wait for result
          xcrun notarytool submit build/ClipClap.zip \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_APP_SPECIFIC_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --wait

          # Staple the notarization ticket to the app
          xcrun stapler staple "build/Export/ClipClap.app"

      - name: Create DMG
        run: |
          brew install create-dmg

          VERSION="${{ needs.build.outputs.version }}"
          APP_PATH="build/Export/ClipClap.app"
          DMG_NAME="ClipClap-${VERSION}.dmg"

          create-dmg \
            --volname "ClipClap" \
            --volicon "${APP_PATH}/Contents/Resources/AppIcon.icns" \
            --window-pos 200 120 \
            --window-size 800 400 \
            --icon-size 100 \
            --icon "ClipClap.app" 200 190 \
            --hide-extension "ClipClap.app" \
            --app-drop-link 600 185 \
            "${DMG_NAME}" \
            "${APP_PATH}" \
            || true

          if [ ! -f "${DMG_NAME}" ]; then
            echo "create-dmg failed, using hdiutil fallback"
            mkdir -p dmg-temp
            cp -R "${APP_PATH}" dmg-temp/
            hdiutil create -volname "ClipClap" -srcfolder dmg-temp -ov -format UDZO "${DMG_NAME}"
            rm -rf dmg-temp
          fi

          echo "DMG created: ${DMG_NAME}"
          ls -lh "${DMG_NAME}"

      - name: Notarize DMG
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          VERSION="${{ needs.build.outputs.version }}"
          DMG_NAME="ClipClap-${VERSION}.dmg"

          # Submit DMG for notarization and wait
          xcrun notarytool submit "${DMG_NAME}" \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_APP_SPECIFIC_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --wait

          # Staple the notarization ticket to the DMG
          xcrun stapler staple "${DMG_NAME}"

      - name: Commit version bump
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add ClipClap/Info.plist
          git commit -m "Bump version to ${{ needs.build.outputs.version }} (build ${{ needs.build.outputs.build }})"
          git tag "v${{ needs.build.outputs.version }}"

      - name: Push changes and tags
        run: |
          git push origin HEAD:main
          git push origin "v${{ needs.build.outputs.version }}"

      - name: Create GitHub Release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          VERSION="${{ needs.build.outputs.version }}"
          BUILD="${{ needs.build.outputs.build }}"

          cat > release-notes.md <<NOTES
          ## ClipClap v${VERSION}

          **Installation:**
          1. Download the DMG file below
          2. Open the DMG
          3. Drag ClipClap to your Applications folder
          4. Launch ClipClap from Applications
          5. Grant accessibility permissions when prompted

          **What's New:**
          - Automated release build ${BUILD}

          **System Requirements:**
          - macOS 12.0 (Monterey) or later
          NOTES

          gh release create "v${VERSION}" \
            "ClipClap-${VERSION}.dmg" \
            --title "ClipClap v${VERSION}" \
            --notes-file release-notes.md

      - name: Cleanup keychain
        if: always()
        run: |
          if [ -n "$KEYCHAIN_PATH" ] && [ -f "$KEYCHAIN_PATH" ]; then
            security delete-keychain "$KEYCHAIN_PATH"
          fi
